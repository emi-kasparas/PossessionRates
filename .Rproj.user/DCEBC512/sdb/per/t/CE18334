{
    "collab_server" : "",
    "contents" : "source(\"mid108(2).R\")\nsource(\"functions.R\")\nlibrary(\"grid\")\n\n#emibase()\nload(\"input/EMI base.RData\")\n\n\noptions(scipen = 7)\n\n# INPUT -------------------------------------------------------------------\n# inputas pasiima pacias naujausias versijas\n\n# is possessions by decile csv file'o, padarome Rdata file'a,\n# kuriame idedam naujus possessions by decile (is csv) ir Average income by decile is senesnio Rdata file'o.\n# dirname1 <- \"input/Possessions by Decile/final_poss_by_decile csv/\"\n# dirname2 <- \"input/Possessions by Decile/final_poss_by_decile RData/\"\n# create.possessions.by.decile.RData(dirname1, dirname2)\n\nload(lastinput(\"input/Possessions by Decile/final_poss_by_decile RData\"))\npd <- arrange(final.pbd,Decile.No,Year,CountryName) # possessions by decile\nkof <- read.csv(file=lastinput(\"input/Income abq\"),check.names=F,stringsAsFactors=F)\npossession_codes <- read.csv(\"input/possession_codes.csv\", check.names=F, stringsAsFactors = F)\nbt <- read.csv(file=\"input/bad things.csv\",check.names=F,stringsAsFactors=F, sep=\";\")\n\n# kodėl reikalingas šitas kof koregavimas? imi 1,3,4 stulpelį ir ten pridedi kažkokius minusus???\nkof <- kof[which(!(duplicated(apply(kof[,c(1,3,4)],1,function(x){paste(x,collapse=\"-\")})))),]\nabqUSD <- kof\n\nccid <- read.csv(file=\"input/city codes id.csv\",check.names=F,stringsAsFactors=F)\n\nyears <- as.character(2005:2030)\n\n# cia ispiesiamas summary abq (bet ji galim ir uzkomentuot, jei ten viskas ok)\nabq.summary.graphs.grubus(kof,filename=\"plots/1. Average income/abq summary \",info1=\"abq Summary\",info2=\"Average, Median, Mode\")\n\n\n# mapping -----------------------------------------------------------------\n\nsplitmap <- read.csv(file=\"input/countries mapping splits.csv\",check.names=F,stringsAsFactors=F)\n\nsplitmap <- ddply(splitmap,~ GraphGroup + GraphName,function(x){\n  x<<-x\n  out <- c(unique(x$CityCode),substr(unique(x$RegionCode),1,4),unique(x$CountryCode))\n  out <- c(unique(x$CityCode),unique(x$CountryCode))\n  out <- data.frame(cbind(CityCode = out,GraphGroup = x$GraphGroup[1],GraphName = x$GraphName[1]))\n  return(out)\n})\n\nosplitmap <- splitmap\n\n# PROCESS -----------------------------------------------------------------\n# recalculating average decile income from countries abq ------------------\n\ncnkof <- kof[kof$CityCode==kof$CountryCode,]\ncnlist <- unique(cnkof$CountryCode)\n\n# suskaičiuoja naujas vidutines pajamas miesto deciliuose, kad po to \n# būtų galima suskaičiuoti possessions\nfor(cn in unique(cnkof$CountryCode)){\n  cat(paste0(\"Average deciles recalculation: \",cn),\"\\n\")\n  \n  xframe <- cnkof[cnkof$CountryCode==cn,] # selecting one country\n  \n  for(y in 2005:2030){\n    theta <- as.numeric(xframe[xframe$Year==y,c(\"a\",\"b.cntUSD\",\"q\")])\n    avgdec <- avgdec.from.qbq(theta)\n    \n    pd[pd$CountryCode==cn & pd$Year==y,\"Average.income\"] <- rep(avgdec,each=length(unique(pd[pd$CountryCode==cn & pd$Year==y,\"Possession\"])))     \n  }\n}\n\n# average cities income recalculation -------------------------------------\n# this code selects cities from kof, takes its a, b, q, \n# and gets city's average income for each year\n\navicity <- kof\n\navicity <- ddply(avicity,~CityCode,function(x){\n  x<<-x\n  print(as.character(x$CityCode[1]))\n  ttt <- b.converter.reverse(x[,\"a\"],x[,\"b.cntUSD\"],x[,\"q\"])\n  out <- data.frame(cbind(x[,1:4],AI=ttt),check.names=F,stringsAsFactors=F)\n  return(out)\n})\n\n#  ------------------------------------------------------------------------\n\nyears <- as.character(2005:2030)\nyears2 <- as.character(2005:2020)\n\n###################\n\n# skaiciuojame viskam, kam turime income distributionus\nukofcncc <- unique(kof[,c(\"CountryCode\",\"CityCode\",\"City\")]) \n\nupcn <- unique(pd[,c(\"CountryCode\",\"Possession\")])\n\n# Pasalinami saliu duomenys (a,b,q), nes gerus pasiimam is Astos\n# ukofcncc <- ukofcncc[ukofcncc$CityCode!=ukofcncc$CountryCode,]\n\n\n# #\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b sita reiks istrint kai noresim visus produktus, bet jei reik tik keliu, tai cia juos issiskiriam\n\n# upcn <- upcn[upcn$Possession %in% c(\"Possession of Mobile Telephone\"),]\n\n# upcn <- upcn[upcn$Possession %in% c(\"Possession of Personal Computer\",\"Possession of Internet Enabled Computer\",\n#                                     \"Possession of Broadband Internet Enabled Computer\"),]\n# #\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\n\n\n## pridedam possessions kiekvienam regionui/miestui\nukofcncc <- merge(ukofcncc,upcn,by=\"CountryCode\",all.x=T)\n## čia išmetam NA eilutes (gal jau ir nebereikia šito)\nukofcncc <- ukofcncc[!is.na(ukofcncc$Possession),]\n## išmetam eilutes, kur šalies kodas = miesto kodas, t.y., total eilutes\nukofcncc <- ukofcncc[ukofcncc$CountryCode!=ukofcncc$CityCode,]\n\n# sukuriamas sablonas outputui sukalti\nrposout <- cbind(ukofcncc,ukofcncc[,rep(1,length(years))])\nnames(rposout)[-1:-4] <- years\nrposout[years] <- NA\n\n# pridedamos TOTAL eilutes, kuriose bus salies possesionai, kad grafikus normaliai piest.. Galima sita ir ismest\nrposout <- ddply(rposout,~ CountryCode + Possession,function(x){\n  x <<- x\n  # })\n  cat(paste0(\"Calculating Country Totals: \",x$CountryCode[1]),\"\\n\")\n  out <- x[1,]\n  out[,c(\"CityCode\",\"City\")] <- rep(\"Total\",2)\n  out[years] <- ddply(pd[pd$CountryCode==out$CountryCode & pd$Possession==out$Possession,c(\"Year\",\"est.Pos.norm\")],\n                      ~Year,function(y){mean(y[,\"est.Pos.norm\"])})$V1\n  out$CityCode <- out$CountryCode\n  return(rbind(x,out))\n})\n\n\n# FORECASTING -------------------------------------------------------------\n# possessions forecasting using income distributions ----------------------\n\nukofcnccl1 <- as.character(unique(ukofcncc$CountryCode)) # tiesiog visos šalys\npd <- arrange(pd,Decile.No)\n\ns3rposout <- rposout # saving some rations just for recovering if needed\n\nfor(indexl1 in 1:length(ukofcnccl1)){ # darome ciklą tiek kartų, kiek yra šalių\n  \n  cn <- as.character(ukofcnccl1[indexl1]) # imam šalį\n  \n  ukofcnccl2 <- ukofcncc[ukofcncc$CountryCode==cn,] # imam jos regionus ir possessionus\n  kofl1 <- kof[kof$CountryCode==cn,] # šalies income distribution parametrai\n  pmatl1 <- pd[pd$CountryCode==cn,] # šalies decilių possession duomenys\n  \n  # dabar jau sukam ciklą tos šalies viduje\n  for(index in 1:nrow(ukofcnccl2)){  \n    \n    cc <- as.character(ukofcnccl2[index,\"CityCode\"]) # konkretus miestas\n    pn <- as.character(ukofcnccl2[index,\"Possession\"]) # konkretus possession\n    \n    # pasižiūrim šalies total duomenis (kuriuos įsidėjom jau anksčiau)\n    tot <- as.numeric(rposout[rposout$CityCode==cn & rposout$Possession==pn,years])\n    \n    cat(paste(\"Forecasting: \",cn,cc,ukofcnccl2[index,\"City\"],pn,sep=\" - \"),\"\\n\")\n    \n    out <- c()\n    kmat <- kofl1[kofl1$CityCode==cc,] # miesto ar regiono income distribution parametrai visiems metams\n    pmat <- pmatl1[pmatl1$Possession==pn,] # šalies decilių possession visiems metams, bet konkretaus possession\n    \n    # gaunam koks miesto income 2005-2030, iš jo distribution\n    cityincome <- b.converter.reverse(kmat$a,kmat$b.cntUSD,kmat$q)\n    avicity[avicity$CityCode %in% c(cn),\"AI\"]\n    \n  \n    for(y in 2005:2030){\n      #       print(y)\n      k <- kmat[kmat$Year==y,] # vienerių metų income distribution parametrai\n      pframe <- pmat[pmat$Year==y,] # šalies possession pagal decilius, vieniems metams)\n      \n      #integruojam ir gaunam possession, kai ciklas prasisuka, tai visiems metams\n      out[y-2004] <- regionalpos(k,pframe,plot=T,starter = tail(pframe$Average.income,1) * 20)\n    }\n    \n    oout <- out\n    \n    # šita funkcija patikrina monotoniškumą - kad possession visąlaik augtų arba visąlaik kristų\n    # iš principo patvarko duomenis labai nedaug\n    out <- hatfun.solve(out,itermax=10,stp=9,plot=T)\n    \n    # monotoniskumas - čia tiems atvejais, kai total (t.y.šalis) visąlaik auga/krenta - \n    # tada griežčiau padaro, kad ir miestas visąlaik mažėtų/augtų.\n    \n    if (substr(cc, 1, 2)==\"UZ\"){ #monotoniskumas tik Uzbekistano atveju uzdetas\n      if(all(diff(tot)<=0) | all(diff(tot)>=0)){\n        out <- mono.pos(out,tot,split = 1)\n      }\n    }\n\n    # matplotg(cbind(oout,out,tot),main=paste(cn,cc,ukofcnccl2[index,\"City\"],pn,sep=\" - \"))\n    \n    rposout[rposout$CountryCode==cn & rposout$CityCode==cc & rposout$Possession==pn,years] <- out\n    \n  }\n}\n\n\n# possessions adjustion using historical data -----------------------------\n\ntier <- read.csv(file=\"input/Region city mapping file.csv\",check.names=F,stringsAsFactors=F)\ntier[,\"RegionCode\"] <- substr(tier[,\"RegionCode\"],1,4)\nregnew <- read.csv(file=\"input/Region codes new.csv\",check.names=F,stringsAsFactors=F)\ntier <- merge(tier,regnew[c(\"RegionCode\",\"RegionCodeOld\")],all.x=T,by=\"RegionCode\")\n\n\ncities.possession.graphs.grubus.only.after.income(rposout,filename=\"plots/2. Forecasted possessions only from income/Forecasted possessions only from income \",\n                                                  info1=\"Possessions of Durables\",info2=\"Forecasts only after income method step\")\n\n# padaromi pritempimai prie originaliu duomenu ----------------------------\n\ns2rposout <- rposout\n# rposout <- s2rposout\nqwe <- rposout\n\nsave(s2rposout,file=paste0(\"temp/\",\"s2rposout only after income\",gsub(\":\",\"-\",Sys.time()),\".Rdata\"))\n# \b\b\b\b\n# load(\"temp/s2rposout only after income2016-06-06 07-19-18.RData\") # sita reikia uzsiloadint, jei norim daryt nuo tos stadijos, kai jau turim susimodeliave pagal income\n# rposout <- s2rposout\n# \b\b\b\n\n# input\n# hp yra historical possessions\n\nhp <- read.csv(file=lastinput(\"input/Original data\"),check.names=F,stringsAsFactors=F)\n\n# išmetam šalis, kurių galėjo būti originaliuose duomenyse, bet mums jų nereikia\nhp <- hp[hp$CountryCode %in% intersect(unique(hp$CountryCode),unique(rposout$CountryCode)),]\n\n# jei yra 2004 metų taškas, priskiriame jį 2005 metams\nhp[apply(hp[,years2],1,function(x){all(is.na(x))}) & !is.na(hp[,\"2004\"]),\"2005\"] <- \n  hp[apply(hp[,years2],1,function(x){all(is.na(x))}) & !is.na(hp[,\"2004\"]),\"2004\"]\n\n# kurie originalus islipa is veziu \nhp[unique(which(hp[,years2]>100,arr.ind = T)[,1]),]\nhp[unique(which(hp[,years2]<0,arr.ind = T)[,1]),]\nhp[duplicated(hp[,c(\"RegionCode\",\"ProductName\")]),]\n\n## \b\nhp <- hp[!duplicated(hp[,c(\"RegionCode\",\"ProductName\")]),]\n\n###\n\n# isbreziami grafikai (sita irgi galim komentuot jei nenorim kad breztu)\n# original.data.barplots(hp,avicity,filename = \"plots/3. Original data barplots/Original data barplots \",info1 = \"Original Data Barplots\",info2 = \"Blue - Total, Green - Region, Yellow - City\")\n\n##\n# idsnames <- unique(hp[,c(\"ProductID\",\"ProductName\")])\npnii <- unique(pd[,c(\"Possession\",\"ProductID\")])\n\n# hp <- hp[hp$CountryCode %in% c(\"CO\"),] # \b\b\b\b\b\b\b\b\b\b\b\b\b\b\n\n#countries and poss for these not making fakes\ndont.make.fakes <- bt[bt$Issue==\"dont.make.fakes\",]\n\n### Kodėl ne visi regionai yra tarp sumodeliuotų?? nes\n### po antro veiksmo sumažėja duomenų\nhpregion <- unique(hp[,c(\"RegionCode\")])\nhpregion <- intersect(hpregion,rposout$CityCode)\n\n# hpregion <- hpregion[!hpregion$RegionCode %in% unique(hp$CountryCode),]\n\n# prikabinimas product ID\nrposout <- merge(rposout,possession_codes,by.x=\"Possession\",by.y=\"ProductName\",all.x=T)\nrposout <- arrange(rposout,CityCode,Possession,CountryCode)\nrposout[is.na(rposout$ProductID) & rposout$Possession==\"Possession of Black and White TV Set\",\"ProductID\"]  <-  2496\n\n#isorderinama, kad is pradziu prikabintu totalus, jei nera, o tik tada miestam uzvarytu\nhpregion <- c(hpregion[hpregion %in% rposout$CountryCode],hpregion[!hpregion %in% rposout$CountryCode])\n\n# hpregion <- c(\"ID\", paste0(\"ID0\", 1:9), paste0(\"ID\", 10:16), paste0(\"R\", 330:362))\n\n###########################################################################\n# FIKTYVIU ORIGINALIU DUOMENU SUKURIMAS -----------------------------------\n###########################################################################\n\n# sukuria fiktyvius duomenis 1) internet ir broadband internet; 2) bei cable TV, satellite, colour TV \n# atvejais, kai yra bent vienas is grupes sukuriami fiktyvus duomenys, \n# pvz. jeigu miestui turim colour TV, tai sukriam sattellite ir cable TV.\n \nhp <- make.fakes(hpregion, hp, dont.make, possession_codes)\n\noriginal.data.barplots(hp,avicity,filename = \"plots/3. Original data barplots/Original data barplots after fakes \",info1 = \"Original Data Barplots\",info2 = \"Blue - Total, Green - Region, Yellow - City\")\n\n###########################################################################\n# 'FIKTYVIŲ DUOMENŲ' PRITEMPIMAS PRIE ORIGINALAUS TAŠKO -------------------\n###########################################################################\n\n### Veiksmų eiliškumas:\n# 1. Ima kiekvieną regioną atskirai (pirmas for ciklas)\n# 2. 'priforecastinamas totalas' - pakoreguojame pagal C&C research total ir Cities research total skirtumą\n# 3. 'suskaiciuojami santykiai ir jie sukalami ant rposout' - visi cities research duomenys pakoreguojami pagal C&C duomenis ADITYVIAI\n# 4. Regionai, kuriems turimi tik miestai, užpildomi pagal to regiono miestų vidurkį.\n# 5. Miestai, kuriems turime tik regioną, suskaiciuojam orginal taska rementis orginaliu region tasku\n#    multiplikatyviai (cia taikome du metodus ir issirenkam viena kuris duoda artimesni durable share \n#    regionui)\n# 6. 'pramusimas over100.v2' - čia pataisome 100% pramušimą su atskira funkcija\n# 7. Grafikai\n\n# rposout - visada yra mūsų visi gaminami duomenys, kažką pakoreguojam, bet paliekam ta patį pavadinimą. \n\ns8rposout <- rposout\n\n# pasiliekame tik tuos istorinius duomenis, kuriuos esame primodeliavę.\nhpregion <- unique(hp[,c(\"CountryCode\",\"ProductName\")])\nhpregion <- hpregion[hpregion$CountryCode %in% rposout$CountryCode & hpregion$ProductName %in% rposout$Possession,]\nhpregion <- arrange(hpregion,CountryCode)\n\n\nlevelhp <- hp\n\nfilename <- \"plots/4. Forecasted possessions adjusted using originals/Forecasted possessions adjusted using originals \"\npdftitle <- paste0(filename,gsub(\":\",\"-\",Sys.time()),\".pdf\")\n\npdf(pdftitle,width=13,height=10)\nprint(titlepage(\"Possessions Forecasts\", \"Before and After Original data adjustion\",date=Sys.time(),size=15,author=\"Povilas Bockus\"))\n\n# which(hpregion[,1]==\"AT\" & hpregion[,2]==\"Possession of Personal Computer\")\n# hpregion <- hpregion[hpregion$CountryCode==\"IN\",]\nkkk <- 1\nfor(index in 1:nrow(hpregion)){\n  \n  cc <- as.character(hpregion[index,\"CountryCode\"])\n  pn <- hpregion[index,\"ProductName\"]\n  \n  hp.cc <- hp[hp$CountryCode==cc & hp$ProductName==pn,]\n  inc.cc <- rposout[rposout$CountryCode==cc & rposout$Possession==pn,]\n  \n  print(paste(cc,pn,sep=\" - \"))\n  \n  # his <- hp[hp$CountryCode == cc & hp$ProductName== pn,]\n  his <- hp.cc\n  his <- his[!duplicated(his[,1]),] ### ŠITIE DUPLICATED TRYNIMAI YRA BLOGAI??? juos reikia sutvarkyt source, bet ne imti ir trinti\n  his <- his[!apply(his[,years2],1,function(x){all(is.na(x))}),] \n  \n  xframe <- rposout[rposout$CountryCode==cc & rposout$Possession==pn,]\n  if(dim(xframe)[1]==0) next\n  if(dim(his)[1]==0) next\n  \n  oxframe <- xframe\n  \n  # priforecastinamas totalas (t.y. dirbam tik su ŠALIES TOTAL - C&C VS Cities)\n  ## gaunam ratio šalis originali (iš 'his') vs šalis sumodeliuota (iš xframe)\n  totalratio <- his[his$CountryName==\"Total\",years2]/xframe[xframe$City==\"Total\",years2]\n  ## užpildom, jei istorinių duomenų yra tik vieni metai\n  if(sum(!is.na(totalratio))==1) totalratio <- rep(totalratio[!is.na(totalratio)],length(totalratio))\n  ## jei yra bent dvi istorinės reikšmės, jis su MASplineVector kažką padaro\n  totalratio <- MASplineVector(totalratio)\n  ## čia kažkodėl užrašome pakoreguotus ŠALIES istorinius (toliau visi miestai pakoreguojami eilutėse 500-515)\n  his[his$CountryName==\"Total\",years2] <- xframe[xframe$City==\"Total\",years2] * totalratio\n  \n  # suskaiciuojami santykiai ir jie sukalami ant rposout\n  levelmat <- his\n  \n  ## jamam jau pakoreguotus šalies total original\n  totaloriginal <- as.numeric(his[his$CountryName==\"Total\",years2])\n  ## čia jamam išmodeliuotus (kurie turbūt sutampa su C&C research)\n  totaldatabase <- as.numeric(xframe[xframe$City==\"Total\",years2])\n  ## Pridedam kiekvienam regionui/miestui skirtumą, koks buvo rastas tarp C&C research ir Cities Research šalies \n  ## duomenų. Kai kur gali gautis neigiami skaičiai ???\n  levelmat[,years2] <- t(apply(levelmat[,years2],1,function(x){as.numeric(x)-totaloriginal + totaldatabase}))\n  \n  #   levelhp[levelhp$CountryCode == cc & levelhp$ProductName== pn,years2] <- levelmat[,years2]\n    \n  # ███████████████████████ pridedami fiktyvus originalus - \n  \n  # regionai, kuriems NĖRA originalių duomenų \n  miss <- intersect(setdiff(xframe$CityCode,levelmat$RegionCode),tier$RegionCode)\n  \n  out <- c()\n  \n  # missing regions adjustion - (KAI TURĖJOME KAŽKOKIUS MIESTŲ DUOMENIS)\n  if(length(miss)!=0){ \n    for(mr in miss){\n      print(paste(\"Missing Region:\",mr))\n      \n      mc <- tier[tier$RegionCode == mr,\"CityCode\"]\n      out <- levelmat[levelmat$CountryName==\"Total\",]\n      out$RegionCode <- mr\n      out[,c(\"Region/CityName\")] <- NA\n      out[,c(\"CountryName\")] <- \"Temp\"\n      \n      # paima visų to regiono miestų vidurkį, ir priskiria jį regionui\n      if(any(mc %in% unique(levelmat$RegionCode))){\n        out[,years2] <- as.numeric(apply(levelmat[levelmat$RegionCode %in% c(mc,cc),years2],2,mean))\n        levelmat <- rbind(levelmat,out)\n        \n      } else next\n      \n      print(out)\n      \n    }\n  }\n  \n  # pridedami fiktyvus originalus miestam, jei turim regionus\n  \n  # regionai, kuriems turim originalių duomenų\n  regs <- intersect(intersect(xframe$CityCode,tier$RegionCode),levelmat$RegionCode)\n  \n  for(rr in regs){\n    \n    ## miestai, kuriame yra tame regione\n    cinr <- tier[tier$RegionCode == rr,\"CityCode\"]\n    ## dar išmetam tuos miestus, kuriems turim originalių duomenų\n    cinr <- intersect(cinr[!cinr %in% unique(levelmat$RegionCode)],xframe$CityCode)\n    \n    if(length(cinr)!= 0){\n      \n      for(i in 1:length(cinr)){\n        \n        x <- oxframe[oxframe$CityCode==cinr[i],years] # miesto possession iš pajamų\n        xreg <- oxframe[oxframe$CityCode==rr,years] # regiono possession iš pajamų\n        ### Čia multiplikatyviai prideda miestus\n        \n        ### čIA IŠ PRADŽIŲ DVIEM SKIRTINGAIS BŪDAIS SPĖJAME MIESTO POSSESSION ATSIŽVELGDAMI Į REGION\n        \n        ## pirmas būdas primityvus multiplikatyvus\n        ratio1 <- x[,years]/xreg\n        ratio2 <- ratio1\n        \n        ## antras būdas labiau komplikuotas, išsamiau aprašytas functions.R faile\n        ratio22 <- fromIncomePossessionCurve(city=cinr[i], cc=cc, pn=pn , rposout=rposout,\n                                            hp=hp, abqUSD=abqUSD, final.pbd=final.pbd, hp.cc, inc.cc)\n        ratio2[,as.character(c(2005:2030))] <- ratio22\n        \n        ### ŠITAS IF IŠRENKA TĄ BŪDĄ, KAI MIESTO SUMODELIUOTI DUOMENYS YRA ARTIMESNI REGIONUI\n        ### (T.Y. TOKS LYG KONSERVATYVESNIS POŽIŪRIS GAUNASI)\n        \n        if (all(is.na(ratio2))){\n          \n          ratio <- ratio1\n        }else{\n          \n          if (abs(1-mean(as.numeric(ratio1))) > abs(1-mean(as.numeric(ratio2)))){\n            ratio <- ratio2\n          }else{\n            ratio <- ratio1\n          }\n        }\n\n        out <- levelmat[levelmat$RegionCode==rr,] # priskiriam ou region duomenis\n        # original.point <-  as.numeric( out[,years2])[!is.na(as.numeric( out[,years2]))][length(as.numeric( out[,years2])[!is.na(as.numeric( out[,years2]))])]\n        # pos.inc <- xreg[,names(out[,years2][!is.na(as.numeric( out[,years2]))][length(as.numeric( out[,years2])[!is.na(as.numeric( out[,years2]))])])]\n        # pos.n <- xframe[xframe$City==\"Total\",names(out[,years2][!is.na(as.numeric( out[,years2]))][length(as.numeric( out[,years2])[!is.na(as.numeric( out[,years2]))])])]\n        out$RegionCode <- cinr[i] # pakeiciam region code, kad out jau butu miesto duomenys\n        out[,years2] <- out[,years2] * ratio[,years2] # out padauginam is region/city ratio (is pajamu)\n        levelmat <- rbind(levelmat,out)\n        \n        # sink(paste0(\"orig only regions/orig only regions_\", kkk, \".txt\"))\n        # print(paste0(\"City changed because of Region: \", cinr[i], \"; \",\"because of \",\n        #              rr, \"; \", pn, \"; \",  mean(as.numeric(ratio1)), \"; \", ratio22, \"; \", original.point,\"; \",\n        #              pos.inc, \"; \", pos.n))\n        # sink()\n        # kkk <- kkk+1\n      }\n    }\n    \n  }\n  \n  levelmat[,years2][levelmat[,years2]>100] <- 100\n  \n    \n  p <- xframe[xframe$City==\"Total\",years]/100\n  \n  #███\n  ## Paima visus šalies miestus ir regionus -  ir tada dar pakoreguoja\n  citymustbetchanged <- intersect(unique(levelmat$RegionCode)[unique(levelmat$RegionCode)!=cc],xframe$CityCode)\n  \n  for(mcc in citymustbetchanged){\n    \n    ### čia mūsų modeliuotas possession iki dabar\n    x <- xframe[xframe$CityCode==mcc,] \n    ### jei dar nesumodeliuovom, praleidžiam\n    if(dim(x)[1]==0) next\n    ### čia grynai originalūs arba sukurti 'fiktyvūs' pagal regionus ankstesniame cikle\n    y <- levelmat[levelmat$RegionCode==mcc,] \n    ### parenkame metus, bet tik tuos kuriems turime kažkokius duomenis (research ar fiktyvius)\n    nnay <- years2[which(!is.na(y[,years2]))]\n    ### originalūs duomenys\n    ymean <- mean(as.numeric(y[,nnay]))\n    ### istoriniai duomenys\n    xmean <- mean(as.numeric(x[,nnay]))\n    \n    ### čia jamam adityvų skirtumą\n    x.aditive <- x[,years] - xmean + ymean\n    ### čia multiplikatyvų skirtumą\n    x.multiplicative <- x[,years] * ymean/xmean\n      \n    ### svorių parinkimo nesupratau - p yra gautas anksčiau tiesiog kaip possession???\n    ### jei possession mažas, tai labiau ima multiplikatyvų. Jei possession didelis\n    ### tada labiau žiūri į adityvų.\n    ### \n    ### o neturėtų šitas priklausyt labiau nuo to, kaip nutolęs originalus nuo \n    ### istorinių duomenų? Nes jei nenutolęs, tai ir problemos gal nėra???\n    x.out <- p * x.aditive + (1-p) * x.multiplicative\n      \n#     }\n#         matplotg(cbind(as.numeric(x.aditive),as.numeric(x.multiplicative),as.numeric(x.out),as.numeric(xframe[xframe$CityCode==mcc,years])),abline=c(0,100))\n    #     matplotg(cbind(as.numeric(x[,years]),as.numeric(x.out),out),stx=2005)\n#         matplotg(cbind(as.numeric(x[,years]),as.numeric(x.out),as.numeric(out)),abline=c(0,100))\n\n    x[,years] <- x.out\n    \n    xframe[xframe$CityCode==mcc,] <- x\n    \n  }\n  \n  # pramusimas over100.v2\n  xframe[,years] <- over100.v2(xframe[,years],plot=F,divover=2,border = 1)\n  # xframe[,years] <- over100.v2(xframe[,years],plot=F,divover=2,border = 1)\n  \n  if(dim(xframe)[1]==0) next\n  \n  ####################################\n  \n  xframe[,years] <- over100.v2(xframe[,years],plot=F,divover=2,border = 1)\n  \n  notchanged <- setdiff(xframe$CityCode[which(apply(oxframe[,years] - xframe[,years],1,mean) == 0)],c(cc,\"Total\"))\n  if(length(notchanged)!=0) print(paste(\"There left few 'CityCodes' which was not changed or was equal (strange):\",notchanged))\n  \n  #███\n  rposout[rposout$CountryCode==cc & rposout$Possession==pn,] <- xframe\n  #███\n  \n  #graphs\n  gdata <- data.frame(t(xframe[,years]))\n  names(gdata) <- xframe$City\n  gdata2 <- gdata\n  gdata2[,] <- t(oxframe[,years])\n  \n  \n  layout(matrix(c(1,2,3,3), 2, 2, byrow = TRUE))\n  \n  matplotf(gdata2,stx=2005,legend=F,text=T,abline=c(0,100),turnoffpar=T,\n           main=paste(xframe$CountryCode[1],xframe$Possession[1],\"Before\",sep=\" - \"))\n  lines(years,as.numeric(xframe[xframe$CityCode==cc,years]),lwd=3)\n  \n  matplotf(gdata,stx=2005,legend=F,text=T,abline=c(0,100),turnoffpar=T,\n           main=paste(xframe$CountryCode[1],xframe$Possession[1],\"After\",sep=\" - \"))\n  lines(years,as.numeric(xframe[xframe$CityCode==cc,years]),lwd=3)\n  \n  matplotf(gdata2,stx=2005,legend=F,text=T,abline=c(0,100),col=\"firebrick3\",turnoffpar=T,\n           main=paste(xframe$CountryCode[1],xframe$Possession[1],sep=\" - \"))\n  matplotf(gdata,stx=2005,legend=F,text=T,abline=c(0,100),col=\"dodgerblue3\",turnoffpar=T,\n           main=paste(xframe$CountryCode[1],xframe$Possession[1],sep=\" - \"),add=T,lwd=2)\n  lines(years,as.numeric(xframe[xframe$CityCode==cc,years]),lwd=3)\n  legend(\"bottomright\",legend = c(\"Before Originals\",\"After Originals\",\"Total\"),col=c(\"firebrick3\",\"dodgerblue3\",\"black\"),lty=1,cex=0.6)\n  \n\n}\n\n\ndev.off()\n\n#regionai, is kuriu padaryti orginalus miestu possessionai (yra orginalus region taskas bet nera city)\n#dvieju variantu ratio sujungiam i viena file'a\n\n# region.list <- NULL\n# for (i in dir(\"orig only regions/\")){\n# \n#   region1 <- read.table(paste0(\"orig only regions/\", i))\n#   region.list <- rbind(region.list, region1)\n# }\n# region.list <- region.list[order(region.list$V2),]\n# \n# sink(\"orig only regions all.txt\")\n# print(region.list$V2)\n# sink()\n\n###########################################################################\n# testing conditions (satellite + cabel < television, etc)-----------------\n###########################################################################\n\ns4rposout <- rposout\nsave(s4rposout,file=paste0(\"temp/\",\"s4rposout after originals adjustion \",gsub(\":\",\"-\",Sys.time()),\".Rdata\"))\n\n# source(\"regions durables conditions testing.R\")\nrposout <- test.all.conditions.cities(rposout)\n\ncities.possession.graphs.grubus(bigdata=rposout,filename=\"plots/5. Forecasted possessions after originals and conditions/Forecasted possessions after originals and conditions \",\n                                info1=\"Possessions of Durables\",info2=\"Forecasts after adjustion using originals and 1 time conditions\")\n\n\nsave(rposout,file=paste0(\"temp/\",\"s4rposout after conditions and original adjustion\",gsub(\":\",\"-\",Sys.time()),\".Rdata\"))\n# load(\"temp/s4rposout after conditions and original adjustion2016-06-06 08-54-08.RData\")\n\n\n###########################################################################\n# galutiniai pataisymai (monotoniskumai ir glodinimai) --------------------\n###########################################################################\n\ns5.rposout <- rposout\n\n# Exceptionu nuskaitymas, kad imtu kitoki pritempimo buda atitinkamai saliai x produktui\nbt.other.method <- bt[bt$Issue==\"originals.other.method\",]\nsource(\"originals_othermethod.R\")\n\nrposout <- issue.smooth(bt, rposout)\nrposout <- issue.stretch.f(bt, rposout)\nrposout <- issue.total.ratio.f(bt, rposout)\n\n################\n# grafikai po pataisymu\ngraphs.Badthings.adjustion(bt, rposout, s5.rposout, \n                           filename= \"plots/6. Badthings adjustion/Badthings adjustion \")\n\n\n###########################################################################\n# fixing where sum(city.poss.hh)>n.poss.hh --------------------------------\n###########################################################################\n\n# tikrinamame, ar pavertus absoliuciomis reiksmemis susumuoti miestu possession of durables nevirsija salies\nhh <- read.csv(file=\"input/number of households 2015-11-23.csv\",check.names = F,stringsAsFactors = F)\n\n# bad.list <- list.cities.surpass.country(hh, rposout)\nrposout <- fixing.cities.surpass.country(hh, rposout, plot=T)\n\n###########################################################################\n# testing conditions ------------------------------------------------------\n###########################################################################\n\ns6.rposout <- rposout\nrposout <- test.all.conditions.cities(rposout,plot=F)\n\nlist.cities.surpass.country(hh, rposout) #turi buti tuscia jeigu ne reiktu kazka pergalvoti!!!!!!\n\n###########################################################################\n# Final Graphs ------------------------------------------------------------ \n###########################################################################\n\ncities.possession.graphs.grubus(rposout,filename=\"plots/7. Forecasted possessions after exeptions/Forecasted possessions after exeptions \",\n                                info1=\"Possessions of Durables\",info2=\"Forecasts after exeptions and conditions check\")\ncities.possession.graphs.grubus.tik.miestai.split(rposout,splitmap,filename=\"plots/8. Forecasted possessions only cities mapping/Forecasted possessions only cities mapping \",\n                                                  info1=\"Possessions of Durables\",info2=\"Forecasts after exeptions and conditions cities splitted\")\n\n\n#  ------------------------------------------------------------------------\n# final graphs ------------------------------------------------------------\n#  ------------------------------------------------------------------------\n\nbigdata <- rposout\ncities.possession.graphs(bigdata)\n# cities.possession.graphs.grubus(bigdata)\n  \n\n# output all ------------------------------------------------------------------\n### pridedami 3 miestai, kuriu nebuvo anksciau, bet jie sutampa su salimi\nBH01 <- add.cities.which.are.equal.to.countries(cc = \"BH\",citycode = \"BH01\",cityname = \"Manama\",pd,rposout)\nKW01 <- add.cities.which.are.equal.to.countries(cc = \"KW\",citycode = \"KW01\",cityname = \"Kuwait City\",pd,rposout)\nQT01 <- add.cities.which.are.equal.to.countries(cc = \"QT\",citycode = \"QT01\",cityname = \"Doha\",pd,rposout)\n\nrposout <- rbind.fill(rposout,BH01,KW01,QT01)\n\nrposout <- rposout[,c(\"CountryCode\",\"CityCode\",\"City\",\"ProductID\",\"Possession\",years)]\noutputname <- paste0(\"output/rposout final \",gsub(\":\",\"-\",Sys.time()),\".csv\")\nwrite.csv(rposout,file=outputname,row.names=F)\n\n# cities output -----------------------------------------------------------\n\nallrposout <- rposout\n\ncitiesposout <- rposout[rposout$CityCode %in% ccid$CityCode,]\ncitiesposout <- merge(citiesposout,ccid[,c(\"CityCode\",\"CityCodeID\")],all.x=T,by.x=\"CityCode\",by.y=\"CityCode\")\n\noutputname <- paste0(\"output/cities output final \",gsub(\":\",\"-\",Sys.time()),\".csv\")\nwrite.csv(citiesposout,file=outputname,row.names=F)\n\n\ncitiesposoutoutput <- citiesposout\ncitiesposoutoutput <- citiesposoutoutput[,c(\"ProductID\",\"CityCodeID\",years)]\nnames(citiesposoutoutput) <- c(\"ProductID\",\"CountryCodeID\",paste0(\"Y\",years))\n\noutputname <- paste0(\"output/cities output with id final \",gsub(\":\",\"-\",Sys.time()),\".csv\")\nwrite.csv(citiesposoutoutput,file=outputname,row.names=F)\n\n\n##check countries and durables where all cities are below country level\n\n# all <- read.csv(\"output/rposout final 2015-11-24 14-25-22.csv\", stringsAsFactors = F, check.names=F)\n# \n# for (cn in setdiff(unique(all$CountryCode), c(\"BH\", \"QT\", \"KW\"))){\n#   \n#   s <- subset(all, CountryCode==cn)\n#   \n#   for (pi in unique(s$ProductID)){\n#     \n#     ss <- subset(s, ProductID==pi)\n#     \n#     ss.city <- ss[ss$CityCode!=ss$CountryCode & !(substr(ss$CityCode, 1, 2) %in% paste0(\"R\", 0:9)),]\n#     \n#     ss.city <- apply(ss.city[,as.character(c(2005:2030))], 2, max)\n#     \n#     ss.country <- ss[ss$CityCode==ss$CountryCode, as.character(c(2005:2030))]\n#     \n#     if (all(as.numeric(ss.city)<as.numeric(ss.country))){\n#       \n#       print(paste(cn, pi, sep=\" - \"))\n#     }\n#   }\n# }\n\n# Compare 2 data frames (this may be commented) ---------------------------\n\n\n# xframe.new <- read.csv(file=\"output/cities output final 2015-11-24 14-26-56.csv\",check.names=F,stringsAsFactors=F)\n#   \n# dirname2 <- \"K:/GMID Research/CITY/1 - Data/0 - Country data dump/CitiesData\"\n# eval(parse(text=paste(\"xframe.old <- read.csv(\",lastinput.zip(dirname2),\", stringsAsFactors=F)\")))\n# xframe.old <- xframe.old[xframe.old$ProductID %in% unique(xframe.new$ProductID),]\n# \n# xframe.old <- xframe.old[, c(\"ProductID\", \"ProductName\", \"CityCountryCode\", \"CityCode\", \"CityName\", \n#                      paste0(\"Y\", c(2005:2030)))]\n# xframe.old <- rename(xframe.old, c(CityName=\"City\", CityCountryCode=\"CityCodeID\", CityName=\"City\",\n#                                    ProductName=\"Possession\"))\n# names(xframe.old) <- gsub(\"^Y\", \"\", names(xframe.old))\n# \n# xframe.old <- merge(xframe.old, city.codes[, c(\"CityCode\", \"CountryCode\")], all.x=T)\n# xframe.old[is.na(xframe.old$CountryCode),] #has to be empty\n# \n# xframe.old <- xframe.old[!(xframe.old$CountryCode==\"SA\" & xframe.old$ProductID==12980),]\n# \n# xframe.old$version <- \"old\"\n# xframe.new$version <- \"new\"\n# \n# compare <- rbind(xframe.old, xframe.new)\n# compare$id <- paste(compare$CityCode, compare$ProductID)\n# \n# years <- as.character(c(2005:2030))\n# \n# compare$changes <- NA\n# \n# for (i in unique(compare$id)){\n#   \n#   old <- mean(as.numeric(compare[compare$id==i & compare$version==\"old\", years]))\n#   new <- mean(as.numeric(compare[compare$id==i & compare$version==\"new\", years]))\n#   \n#   changed <- abs((new-old)/old)*100\n#   compare[compare$id==i,]$changes <- changed\n# }\n# \n# \n# write.csv(compare, \"output/chnages comparing with old poss.csv\", row.names=F)\n\n\n\n# changed.frame <- compare2data.frames(xframe.new,xframe.old)\n\n\n\n",
    "created" : 1463642961675.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1104782583",
    "id" : "CE18334",
    "lastKnownWriteTime" : 1465491319,
    "last_content_update" : 1465491319640,
    "path" : "C:/Users/Domantas/Desktop/justes/PossessionRates/regions durables.R",
    "project_path" : "regions durables.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}